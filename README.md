# LeetCodeLearn
学习算法基础知识以及对应高频题目的解决

IDE刷题插件：(推荐IntelliJ,可以查看MD文件)
https://github.com/shuzijun/leetcode-editor/blob/master/README_ZH.md

目录：
1. Array数组
2. Linked List链表
3. 栈
4. 队列
5. Tree数
6. 遍历、排序
7. 分治
8. 动态规划

## 2.链表
递归的模板：
```
public ListNode reverseList(参数0) {
    if (终止条件)
        return;

    逻辑处理（可能有，也可能没有，具体问题具体分析）

    //递归调用
    ListNode reverse = reverseList(参数1);

    逻辑处理（可能有，也可能没有，具体问题具体分析）
}
```

解决链表问题的技巧：
1. 将某个变量赋值给引用，实际上就是把这个变量的地址赋值给引用，如：p.next = q,表示将q的地址赋值给p.next
2. 警惕指针丢失，要注意操作的顺序
3. 利用哨兵简化实现难度---解决边界问题，如：插入第一个节点和删除最后一个节点，使用哨兵可以当成普通节点处理
4. 重点留意边界条件处理，比如：链表为空、链表只有一个节点、链表只有两个节点、代码逻辑处理头尾节点的逻辑等
5. 举例画图
6. 多写多练
    6.1 单链表反转（206）
    6.2 链表中环的检测（141）
    6.3 两个有序链表的合并（21）
    6.4 删除倒数第n个节点（19）
    6.5 求链表中间节点（876）
    
## 3.栈
leetcode题集：20、155、232、844、224、682、496

## 4.队列
问题1：队列的使用场景

问题2：如何无锁实现并发队列

## 递归
递归的三要素：
1. 问题可分解
2. 子问题除数据规模不同，求解思路一致
3. 终止条件

如何写递归代码：
1. 找到递归公式；
2. 找到终止条件

递归优化：
1. 避免重复计算（将计算过的结果存起来i->f(i)）

## 排序
排序算法 | 时间效率 | 是否基于比较
--- | --- | ---
冒泡、插入、选择 | O(n2) | 是
快排、归并| O(nlogn) | 是
桶、计数、基数| O(n) | 否

评价算法的几个尺度：
1. 执行效率

    1.1 最好情况、最坏情况、平均情况时间复杂度
    
    1.2 时间复杂度的系数、常数、低阶
    
    1.3 比较次数和交换（或移动）次数
2. 内存消耗
3. 算法的稳定性---值相同的元素，排序后先后顺序不变  

### 冒泡排序
原理：你比后面的高，你就换到后面，矮子里拔高个

稳定性：稳定  

最好：O(n)---如果本次循环没有比较过，则该数组已有序，可以跳出循环

空间复杂度：O(1)

## 插入排序
原理：将一个数插入到有序数组里。将数组分为已排序和待排序两部分，每次将待排序的一个元素插入到已排序数组内，经过n次就能让数组顺序了！

空间复杂度：O(1)

最好时间复杂度：O（n），数组已排序好的情况下

最坏时间复杂度：O（n2），数组元素是逆序的情况下

稳定性：稳定

## 选择排序
原理：与插入排序类似，也是将数组分为已排序和待排序两部分，区别在于每次找到待排序最小的元素，与待排序第一个元素交换位置

空间复杂度：O(1)

最好时间复杂度：O(n2)

最坏时间复杂度：O(n2)

稳定性：不稳定---每次找的都是最小的元素，然后与第一个元素交换位置，这时候会打乱原来的位置

## 冒泡与插入的选择
优先使用插入排序

原因：插入基本操作只有赋值操作，而冒泡基本操作是交换需要三次

